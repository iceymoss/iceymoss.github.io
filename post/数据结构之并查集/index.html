<!doctype html><html lang=zh-cn><head><title>数据结构之并查集 // iceymoss - 刻意练习，卷无止境</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="iceymoss"><meta name=description content><link rel=stylesheet href=/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css><meta name=twitter:card content="summary"><meta name=twitter:title content="数据结构之并查集"><meta name=twitter:description content="[toc] 并查集基础 概念及其介绍 并查集是一种树型结构，用于处理一些不相交集合的合并及查询问题。 并查集的思想是用一个数组表示了整片森林（parent）"><meta property="og:title" content="数据结构之并查集"><meta property="og:description" content="[toc] 并查集基础 概念及其介绍 并查集是一种树型结构，用于处理一些不相交集合的合并及查询问题。 并查集的思想是用一个数组表示了整片森林（parent）"><meta property="og:type" content="article"><meta property="og:url" content="https://iceymoss.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%B9%B6%E6%9F%A5%E9%9B%86/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-05-25T20:12:18+08:00"><meta property="article:modified_time" content="2023-05-25T20:12:18+08:00"></head><body><header class=app-header><a href=https://iceymoss.github.io/><img class=app-header-avatar src=/avatar.jpg alt=iceymoss></a>
<span class=app-header-title>iceymoss - 刻意练习，卷无止境</span><nav class=app-header-menu><a class=app-header-menu-item href=/>首页</a>
-
<a class=app-header-menu-item href=/archives/>归档</a>
-
<a class=app-header-menu-item href=/tags/>标签</a>
-
<a class=app-header-menu-item href=/categories/>类别</a>
-
<a class=app-header-menu-item href=/about/>关于</a></nav><p>iceymoss's blog, Golang Python Developer Life</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>数据结构之并查集</h1><div class=post-meta><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 25, 2023</div><div><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>8 min read</div></div></header><div class=post-content><p>[toc]</p><h3 id=并查集基础>并查集基础</h3><h4 id=概念及其介绍>概念及其介绍</h4><p>并查集是一种树型结构，用于处理一些不相交集合的合并及查询问题。
并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。
对于并查集主要支持两个操作：</p><ul><li>并{ union(p,q) }</li><li>查找{ find(p) }
来回答一个问题：</li></ul><blockquote><p>连接{ inConnected(p, q) }</p></blockquote><h4 id=并查集的基本数据表示>并查集的基本数据表示</h4><p><strong>难点分析：横向上的数值其实是对应横线下数据的在数组中的索引值，也就是说横线下是一个真正的数组，而横线上则是数组对应的索引，在这里我们是用索引当作元素，用数组数据值的异同来表示元素是否连接。</strong></p><p>横线上：用数组索引表示元素
横线下：表示连接情况(值为0的表示在一个集合即连接)
所以0-4在同一个集合，5-9在同一个集合：
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/W2b78bXxZA.png!large alt="并查集(Union Find)"></p><h4 id=代码实现>代码实现</h4><p>下面我们来介绍并查集的主要操作：
我们先实现一个并查集：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 我们的第一版Union-Find
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>namespace</span> UF1 {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnionFind</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>id;         <span style=color:#75715e>// 第一版Union-Find本质就是一个数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> count;     <span style=color:#75715e>// 数据个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   UnionFind(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>         count <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>         id <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[n];
</span></span><span style=display:flex><span> <span style=color:#75715e>// 初始化, 每一个id[i]指向自己, 没有合并的元素,每一个数都是一个集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>           id[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// 析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#f92672>~</span>UnionFind() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span>[] id;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol><li>find的实现：(查询元素所在的集合编号，直接返回数组值，O(1) 的时间复杂度。)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#75715e>// 查找过程, 查找元素p所对应的集合编号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>        assert(p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;</span> count);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> id[p];
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=2><li>isConnected的实现：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#75715e>// 查看元素p和元素q是否所属一个集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// O(1)复杂度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isConnected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ol start=3><li>union的实现：(合并元素 p 和元素 q 所属的集合， 合并过程需要遍历一遍所有元素, 再将两个元素的所属集合编号合并，这个过程是 O(n) 复杂度。)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#75715e>// 合并元素p和元素q所属的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// O(n) 复杂度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unionElements</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {   <span style=color:#75715e>//union在c++中是一个关键字，所以这里用 unionElements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pID <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> qID <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pID <span style=color:#f92672>==</span> qID)
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// 合并过程需要遍历一遍所有元素, 将两个元素的所属集合编号合并
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (id[i] <span style=color:#f92672>==</span> pID)
</span></span><span style=display:flex><span>                    id[i] <span style=color:#f92672>=</span> qID;
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h3 id=并查集的另一种实现思路优化>并查集的另一种实现思路(优化)</h3><h4 id=介绍>介绍</h4><p>在并查集的Union( ) 中使用指针，将每一个元素看作是一个节点，并将每一个节点都指向一个节点(可以是其他节点或节点本身)即Quick Union；使用这种方法在后续可以更好的对并查集进行优化。</p><h4 id=union的表示方法及逻辑>Union的表示方法及逻辑</h4><p><strong>在Quick Find下的union时间复杂度为( O(n) )</strong>
将每一个元素看作是一个节点，如下图：
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/pSWl8xXjTL.png!large alt=并查集系列之「思路优化」></p><p>初始化一样，每一个元素是一个集合</p><p><img src=https://cdn.learnku.com/uploads/images/202105/21/69310/02sZecHIhS.png!large alt=并查集系列之「思路优化」></p><p>并且每一个元素指向自己
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/Gk56Lo90JH.png!large alt=并查集系列之「思路优化」></p><p>下面我们将4，3连接( union(4, 3) )
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/iI1C8j5sp3.png!large alt=并查集系列之「思路优化」></p><p>再继续：将3，和8连接(union(3, 8) )
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/qWmbJGYBlj.png!large alt=并查集系列之「思路优化」></p><p>将6，5进行连接( union(6, 5) )
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/yzkiK7Nh6g.png!large alt=并查集系列之「思路优化」></p><p><strong>这里注意：我们将9，4连接( union(9, 4) )
我们是将9指向8节点(这样更优化)，在逻辑上就是9，和4连接上了</strong>
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/OinW4hkQyG.png!large alt=并查集系列之「思路优化」></p><p>再看这里，同样的逻辑，将其中一方的根节点指向另一个的根节点
连接6，2 ( union(6, 2) )
<img src=https://cdn.learnku.com/uploads/images/202105/21/69310/dmikxC0x7L.png!large alt=并查集系列之「思路优化」>
连接后：</p><p><img src=https://cdn.learnku.com/uploads/images/202105/21/69310/s0NGkkQl1K.png!large alt=并查集系列之「思路优化」></p><p>优化后的表示方法及逻辑就是这样。</p><h4 id=代码实现-1>代码实现</h4><p>我先看union部分：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// 合并元素p和元素q所属的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e>// O(h)复杂度, h为树的高度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unionElments</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {    <span style=color:#75715e>//union在c++中是关键字
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> pRoot <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> qRoot <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pRoot <span style=color:#f92672>==</span> qRoot)
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     parent[pRoot] <span style=color:#f92672>=</span> qRoot;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是完整代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UF2 {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnionFind2</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>               <span style=color:#75715e>// parent[i]表示第i个元素所指向的父节点 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>parent;
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>int</span> count; <span style=color:#75715e>//数据个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            UnionFind2(<span style=color:#66d9ef>int</span> count) {
</span></span><span style=display:flex><span>                parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>count <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>               <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                       parent[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>            <span style=color:#75715e>//析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#f92672>~</span>UnionFind2() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>delete</span> parent;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>           <span style=color:#75715e>// 查找过程, 查找元素p所对应的集合编号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>                assert(p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;=</span> count);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 不断去查询自己的父亲节点, 直到到达根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 根节点的特点: parent[p] == p  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> parent[p])
</span></span><span style=display:flex><span>                           p <span style=color:#f92672>=</span> parent[p];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 查看元素p和元素q是否所属一个集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// O(h)复杂度, h为树的高度 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isConnected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 合并元素p和元素q所属的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>               <span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unionElments</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>int</span> pRoot <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>int</span> qRoot <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                      <span style=color:#66d9ef>if</span> (pRoot <span style=color:#f92672>==</span> qRoot)
</span></span><span style=display:flex><span>                           <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                      parent[pRoot] <span style=color:#f92672>=</span> qRoot;
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=并查集基于size的优化>并查集基于size的优化</h3><h4 id=介绍及逻辑>介绍及逻辑</h4><h5 id=介绍-1>介绍</h5><p>在上一小节我们使用指针的方法将每一个元素都看作是一个节点，并且是节点指向另一个节点(包括自己)，在这一小节中我们将在此基础上进行优化。
先来介绍一下什么是"size"
size : size[i] 是指用来记录以i为根节点的树所包含的节点个数，本质是一个数组</p><h5 id=逻辑>逻辑</h5><p>先来看看下面的图片：
现在需要将4，2连接起来，该怎么连？</p><p><img src=https://cdn.learnku.com/uploads/images/202105/21/69310/J8VFokGlwg.png!large alt=并查集系列之「基于sz的优化」></p><p><strong>方法一：如下图</strong></p><p><img src=https://cdn.learnku.com/uploads/images/202105/21/69310/PNOaC19gPA.png!large alt=并查集系列之「基于sz的优化」></p><p><strong>方法二：如下图</strong></p><p><img src=https://cdn.learnku.com/uploads/images/202105/21/69310/b5sFOe2Zmy.png!large alt=并查集系列之「基于sz的优化」></p><p>很容易看出方法二更优，树的高度越高，对计算机的消耗也会越大，所以很明显方法二是有3层，而方法一有4层(一旦有大量的数据时，性能差别就会明显)； 所以我们使用size数组，就是在维护方法二。</p><h4 id=代码实现-2>代码实现</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UF3 {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnionFind2</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// parent[i]表示第i个元素所指向的父节点 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>parent;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>size;  <span style=color:#75715e>//size用来记录节点的个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> count; <span style=color:#75715e>//数据个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        UnionFind2(<span style=color:#66d9ef>int</span> count) {
</span></span><span style=display:flex><span>            parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>            size <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>count <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                parent[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>                size[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>         <span style=color:#75715e>//析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>~</span>UnionFind2() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> parent;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> size;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找过程, 查找元素p所对应的集合编号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// O(h)复杂度, h为树的高度 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>            assert(p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;=</span> count);
</span></span><span style=display:flex><span>           <span style=color:#75715e>// 不断去查询自己的父亲节点, 直到到达根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#75715e>// 根节点的特点: parent[p] == p  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> parent[p])
</span></span><span style=display:flex><span>                  p <span style=color:#f92672>=</span> parent[p];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看元素p和元素q是否所属一个集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// O(h)复杂度, h为树的高度 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isConnected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>下面是size的核心：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>         <span style=color:#75715e>// 合并元素p和元素q所属的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unionElments</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> pRoot <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> qRoot <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pRoot <span style=color:#f92672>==</span> qRoot)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>             <span style=color:#75715e>// 根据两个元素所在树的元素个数不同判断合并方向
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>             <span style=color:#75715e>// 将元素个数少的集合合并到元素个数多的集合上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(size[pRoot] <span style=color:#f92672>&lt;</span> size[qRoot]) {
</span></span><span style=display:flex><span>                parent[pRoot] <span style=color:#f92672>=</span> qRoot;
</span></span><span style=display:flex><span>                size[qRoot] <span style=color:#f92672>=</span> <span style=color:#f92672>+</span>size[pRoot];
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {   <span style=color:#75715e>//size[pRoot] &gt;= size[qRoot]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                parent[qRoot] <span style=color:#f92672>=</span> pRoot;
</span></span><span style=display:flex><span>                size[pRoot] <span style=color:#f92672>=</span> <span style=color:#f92672>+</span>size[qRoot];
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=并查集基于rank的优化>并查集基于rank的优化</h3><h4 id=介绍-2>介绍</h4><h5 id=背景>背景</h5><p>前面将到并查集基于size的优化，其实仔细想想，还是有可以优化的地方；size[i]是指以i为根节点树的节点数；是将节点数量多的树的根节点向节点数好的树的根节点连接，在一般情况下是得到了优化，但是这里就存在问题了，当出现：节点数多的树它的高度非常高的时候，size的优化方式就不太高效了。</p><h5 id=rank>rank</h5><p>rank[i]:是用来记录以i为根节点的树的高度(树的层数)，其本质是数组。</p><h4 id=逻辑-1>逻辑</h4><p>并查集本质是树，当树的高度(层数)越高在对数的操作其复杂度会越高，rank的目的就是降低在并(union)过程中并查集的高度；在并(union)过程中使用rank来记录合并的两棵树的高度，将rank值小的树的根节点指向rank值大的根节点。如下图：
连接2，4( union(4,2) )
<img src=https://cdn.learnku.com/uploads/images/202105/22/69310/YDIx4TP9hT.png!large alt=并查集系列之「基于rank的优化」></p><p><strong>方法一：</strong></p><p><img src=https://cdn.learnku.com/uploads/images/202105/22/69310/pcq47Hzxu9.png!large alt=并查集系列之「基于rank的优化」></p><p><strong>方法二：</strong></p><p><img src=https://cdn.learnku.com/uploads/images/202105/22/69310/btOv0IbCcb.png!large alt=并查集系列之「基于rank的优化」></p><p>很明显方法二比方法一更优
<strong>方法二：正是基于rank的优化
具体逻辑如下：</strong>
rank[7] = 2
rank[8] = 3
<img src=https://cdn.learnku.com/uploads/images/202105/22/69310/8dC4QvFYAl.png!large alt=并查集系列之「基于rank的优化」></p><p>此时只需要将rank[7]树的根节点指向rank[8]树的节点
合并后，如下：
此时整个并查集rank[8] = 3,高度不变
<img src=https://cdn.learnku.com/uploads/images/202105/22/69310/q0FoZBCdE7.png!large alt=并查集系列之「基于rank的优化」></p><h4 id=代码实现-3>代码实现</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UF4 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnionFind4</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// parent[i]表示第i个元素所指向的父节点 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>parent;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>rank;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> count; <span style=color:#75715e>//数据个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        UnionFind4(<span style=color:#66d9ef>int</span> count) {
</span></span><span style=display:flex><span>            parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>            rank <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>count <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                parent[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>      <span style=color:#75715e>//析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#f92672>~</span>UnionFind4() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> parent;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> rank;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找过程, 查找元素p所对应的集合编号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>            assert(p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;=</span> count);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 不断去查询自己的父亲节点, 直到到达根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// 根节点的特点: parent[p] == p  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> parent[p])
</span></span><span style=display:flex><span>                p <span style=color:#f92672>=</span> parent[p];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看元素p和元素q是否所属一个集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// O(h)复杂度, h为树的高度 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isConnected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>rank核心部分:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// 合并元素p和元素q所属的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unionElments</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> pRoot <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> qRoot <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pRoot <span style=color:#f92672>==</span> qRoot)
</span></span><span style=display:flex><span>                 <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rank[pRoot] <span style=color:#f92672>&gt;</span> rank[qRoot]) {
</span></span><span style=display:flex><span>                 parent[pRoot] <span style=color:#f92672>=</span> qRoot;
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (rank[pRoot] <span style=color:#f92672>&lt;</span> rank[qRoot]) {
</span></span><span style=display:flex><span>                 parent[qRoot] <span style=color:#f92672>=</span> pRoot;
</span></span><span style=display:flex><span>            } 
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {<span style=color:#75715e>//rank[pRoot] == rank[qRoot]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                  parent[qRoot] <span style=color:#f92672>=</span> pRoot;
</span></span><span style=display:flex><span>                  rank[qRoot] <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><h3 id=并查集的路径压缩>并查集的路径压缩</h3><h4 id=介绍-3>介绍</h4><p>并查集里的 find 函数里可以进行路径压缩，是为了更快速的查找一个点的根节点。对于一个集合树来说，它的根节点下面可以依附着许多的节点，因此，我们可以尝试在 find 的过程中，从底向上，如果此时访问的节点不是根节点的话，那么我们可以把这个节点尽量的往上挪一挪，减少数的层数，这个过程就叫做路径压缩。
通俗的说就是把find过程中“查找节点”的路劲变短，让find能更快的更高效。</p><h4 id=逻辑-2>逻辑</h4><p>例如：find( 4 )
我们需要从下到上的找到根节点，当这条路劲很长，逻辑上花费的时间就会多一些
<img src=https://cdn.learnku.com/uploads/images/202105/22/69310/b2Topkt1Gp.png!large alt=并查集系列之「路径压缩」>
在路劲压缩的这个过程需要不断去查询自己的父亲节点, 直到到达根节点，而根节点的特点: parent[p] == p
不断的将节点4网上挪一挪使用：
<strong>parent[p] = parent[parent[p]];</strong>
<img src=https://cdn.learnku.com/uploads/images/202105/22/69310/Y0lrtM2zAE.png!large alt=并查集系列之「路径压缩」>
最后就完成了路径压缩：</p><p><img src=https://cdn.learnku.com/uploads/images/202105/22/69310/5NqTDviDGT.png!large alt=并查集系列之「路径压缩」></p><h4 id=代码实现-4>代码实现</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> UF4 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UnionFind5</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#75715e>// parent[i]表示第i个元素所指向的父节点  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>parent;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>rank;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>int</span> count; <span style=color:#75715e>//数据个数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>          UnionFind5(<span style=color:#66d9ef>int</span> count) {
</span></span><span style=display:flex><span>            parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>            rank <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[count];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>count <span style=color:#f92672>=</span> count;
</span></span><span style=display:flex><span>           <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> count; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                   parent[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>UnionFind5() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> parent;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> rank;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查找过程, 查找元素p所对应的集合编号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#75715e>// O(h)复杂度, h为树的高度 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>find</span>(<span style=color:#66d9ef>int</span> p) {
</span></span><span style=display:flex><span>            assert(p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> p <span style=color:#f92672>&lt;=</span> count);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 不断去查询自己的父亲节点, 直到到达根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// 根节点的特点: parent[p] == p  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> parent[p])
</span></span><span style=display:flex><span>                parent[p] <span style=color:#f92672>=</span> parent[parent[p]];
</span></span><span style=display:flex><span>                p <span style=color:#f92672>=</span> parent[p];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span> <span style=color:#75715e>//递归算法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>//    if (p != parent[p])
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>//          parent[p] = find(p); 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>//          return parent[p];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 查看元素p和元素q是否所属一个集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isConnected</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> find(p) <span style=color:#f92672>==</span> find(q);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 合并元素p和元素q所属的集合
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#75715e>// O(h)复杂度, h为树的高度  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unionElments</span>(<span style=color:#66d9ef>int</span> p, <span style=color:#66d9ef>int</span> q) {
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>int</span> pRoot <span style=color:#f92672>=</span> find(p);
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>int</span> qRoot <span style=color:#f92672>=</span> find(q);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span> (pRoot <span style=color:#f92672>==</span> qRoot)
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>if</span> (rank[pRoot] <span style=color:#f92672>&gt;</span> rank[qRoot]) {
</span></span><span style=display:flex><span>                    parent[pRoot] <span style=color:#f92672>=</span> qRoot;
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (rank[pRoot] <span style=color:#f92672>&lt;</span> rank[qRoot]) {
</span></span><span style=display:flex><span>                    parent[qRoot] <span style=color:#f92672>=</span> pRoot;
</span></span><span style=display:flex><span>             }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {<span style=color:#75715e>//rank[pRoot] == rank[qRoot]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    parent[qRoot] <span style=color:#f92672>=</span> pRoot;
</span></span><span style=display:flex><span>                    rank[qRoot] <span style=color:#f92672>=</span> <span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(图片来源：慕课网课程《算法与数据结构》)</p></div><div class=post-footer></div></article></main></body></html>