<!doctype html>
<html lang="zh-cn">
  <head>
    <title>数据结构之二分搜索树 // iceymoss - 刻意练习，卷无止境</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.111.3">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="iceymoss" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构之二分搜索树"/>
<meta name="twitter:description" content="[toc] 概念及其介绍 概念 二分搜索树（英语：Binary Search Tree），也称为 二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件： 每个节"/>

    <meta property="og:title" content="数据结构之二分搜索树" />
<meta property="og:description" content="[toc] 概念及其介绍 概念 二分搜索树（英语：Binary Search Tree），也称为 二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件： 每个节" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iceymoss.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-05-25T20:11:27+08:00" />
<meta property="article:modified_time" content="2023-05-25T20:11:27+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://iceymoss.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="iceymoss" /></a>
      <span class="app-header-title">iceymoss - 刻意练习，卷无止境</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/">首页</a>
             - 
          
          <a class="app-header-menu-item" href="/archives/">归档</a>
             - 
          
          <a class="app-header-menu-item" href="/tags/">标签</a>
             - 
          
          <a class="app-header-menu-item" href="/categories/">类别</a>
             - 
          
          <a class="app-header-menu-item" href="/about/">关于</a>
      </nav>
      <p>iceymoss&#39;s blog, Golang Python Developer Life</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">数据结构之二分搜索树</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 25, 2023
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          15 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>[toc]</p>
<h3 id="概念及其介绍">概念及其介绍</h3>
<h4 id="概念">概念</h4>
<p>二分搜索树（英语：Binary Search Tree），也称为 二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件：</p>
<ul>
<li>每个节点的键值大于左孩子</li>
<li>每个节点的键值小于右孩子</li>
<li>以左右孩子为根的子数仍然为二分搜索树
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/uMbx1I3tDl.png!large" alt="二分搜索树"></li>
</ul>
<ol start="2">
<li>优点
可以高效的查找数据，还可以高效的插入，删除，及动态维护数据
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/SCc5xagjcj.png!large" alt="二分搜索树"></li>
</ol>
<p>二分搜索树有着高效的插入、删除、查询操作。
平均时间的时间复杂度为 O(log n)，最差情况为 O(n)。二分搜索树与堆不同，不一定是完全二叉树，底层不容易直接用数组表示故采用链表来实现二分搜索树。
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/kLSU2IkNnS.png!large" alt="二分搜索树"></p>
<h4 id="特性">特性</h4>
<h5 id="顺序性">顺序性</h5>
<p>二分搜索树可以当做查找表的一种实现。</p>
<p>我们使用二分搜索树的目的是通过查找 key 马上得到 value。minimum、maximum、successor（后继）、predecessor（前驱）、floor（地板）、ceil（天花板、rank（排名第几的元素）、select（排名第n的元素是谁）这些都是二分搜索树顺序性的表现。</p>
<h5 id="局限性">局限性</h5>
<p>二分搜索树在时间性能上是具有局限性的。</p>
<p>如下图所示，元素节点一样，组成两种不同的二分搜索树，都是满足定义的：</p>
<p><img src="https://cdn.learnku.com/uploads/images/202105/20/69310/f6ppCo7p6A.png!large" alt="二分搜索树系列之【特性及完整源代码-code】"></p>
<p>二叉搜索树可能退化成链表，相应的，二叉搜索树的查找操作是和这棵树的高度相关的，而此时这颗树的高度就是这颗树的节点数 n，同时二叉搜索树相应的算法全部退化成 O(n) 级别。</p>
<h4 id="操作二分搜索树">操作：二分搜索树</h4>
<ol>
<li>
<p>插入操作(insert)</p>
</li>
<li>
<p>数据的查找(Search)</p>
</li>
<li>
<p>二分搜索树的包含(Contain)</p>
</li>
<li>
<p>二分搜索树的遍历</p>
</li>
<li>
<p>二分搜索树节点删除</p>
</li>
</ol>
<h3 id="二分搜索树节点的插入">二分搜索树节点的插入</h3>
<h4 id="定义二分搜索树">定义二分搜索树</h4>
<p>首先定义一颗二分搜索树，C++代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cassert&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//套用模板函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Key, <span style="color:#66d9ef">typename</span> Value<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BST</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//构造节点Node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>        Key key;
</span></span><span style="display:flex;"><span>  Value value;
</span></span><span style="display:flex;"><span>  Node <span style="color:#f92672">*</span>left;     <span style="color:#75715e">//左孩子指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node <span style="color:#f92672">*</span>right;    <span style="color:#75715e">//右孩子指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  Node(Key key, Value value) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//初始值为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>        Node(Node <span style="color:#f92672">*</span>node){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>key;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    BST() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//初始值为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  root <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>BST() {
</span></span><span style="display:flex;"><span>        distroy(root);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h4 id="插入节点">插入节点</h4>
<p>接下来我们开始对二分搜索树中进行插入节点，如图：</p>
<p><em><strong>我们向树中插入键值为60的节点</strong></em></p>
<ol>
<li>首先60会和整个数的根节点比较，显然60 &gt; 41 所以将60，继续和41节点的右孩子进行比较：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/9ZKbjOlGXe.png!large" alt="二分搜索树系列之【 插入操作 (insert) 】"></li>
<li>此时 60 &gt; 58 ，所以将60 继续和58节点的右孩子节点进行比较，但58节点的右孩子为空，这时 60 节点就插入为58节点的右孩子：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/LTMaoHDqvL.png!large" alt="二分搜索树系列之【 插入操作 (insert) 】"></li>
</ol>
<p><em><strong>下面我们再向二分搜索树中插入键值为28的节点：</strong></em></p>
<ol>
<li>节点28和二分搜索树的根节点41比较，28 &lt; 41 ,将28继续和41节点的左孩子节点比较：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/SsnnXGDKfv.png!large" alt="二分搜索树系列之【 插入操作 (insert) 】"></li>
<li>此时28  &gt;  22, 再将28和22节点的左孩子比较：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/fRm2tFqRZh.png!large" alt="二分搜索树系列之【 插入操作 (insert) 】"></li>
<li>28  &lt; 33,继续将节点28和33节点的右孩子比较，但此时33的左孩子为空，28节点就插入为节点33的左孩子：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/JnlgDvdqkl.png!large" alt="二分搜索树系列之【 插入操作 (insert) 】"></li>
</ol>
<p><em><strong>如果出现插入的节点和二分搜索树中的节点重合的情况，依然是同理，只需要将原来节点覆盖即可</strong></em></p>
<h4 id="代码实现">代码实现</h4>
<p>新节点的插入操作的逻辑明白了，下面我们开始带着这种逻辑进入代码的实现(使用递归版本，c++实现）：
我们在public中定义函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//插入操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(Key key, Value value) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//向根节点中插入key， value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  root <span style="color:#f92672">=</span> insert(root, key, value);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来我们在private中写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//插入操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//向以node为根节点的二分搜索树中，插入节点（key，value),使用递归算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//返回插入新节点后的二分搜索树的根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node <span style="color:#f92672">*</span><span style="color:#a6e22e">insert</span>(Node <span style="color:#f92672">*</span>node, Key key, Value value) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Node(key, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>  } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">-&gt;</span>right, key, value);
</span></span><span style="display:flex;"><span>  } 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#75715e">//key &lt; node-&gt;key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">-&gt;</span>left, key, value);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二分搜索树之查找search-包含contain">二分搜索树之查找(Search)-包含(Contain)</h3>
<h4 id="查找search">查找(Search)</h4>
<h5 id="逻辑">逻辑</h5>
<p>前面我们了解了对节点的插入，其实在二分搜索树中对相应节点的查找的过程中也有同样的逻辑
<em><strong>下面我们来看看具体的查找(Search):</strong></em>
我们在树中查找键值为42的节点</p>
<ol>
<li>
<p>将42和41比较，42 &gt; 41,根据二分搜索树的定义可知，我们应该继续往41节点的右孩子查找：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/NtktXP2oDj.png!large" alt="二分搜索树系列之【查找(Search)-包含(Contain)】"></p>
</li>
<li>
<p>此时再将42和58比较，42 &lt; 58,继续向58节点的左孩子节点查找
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/Wghy1zThDV.png!large" alt="二分搜索树系列之【查找(Search)-包含(Contain)】"></p>
</li>
<li>
<p>42 &lt; 50,继续向50节点的左孩子查找，此时50节点的左孩子就为42，所以我们就找到了节点42，并返回对应的value值
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/UeJALmBqhY.png!large" alt="二分搜索树系列之【查找(Search)-包含(Contain)】"></p>
</li>
</ol>
<p><em><strong>如果我们要查找的节点不存在，则返回空或false</strong></em></p>
<h5 id="代码实现使用递归c实现">代码实现(使用递归，c++实现)</h5>
<p>在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//找到key相应的节点并且返回value的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span><span style="color:#a6e22e">seacher</span>(Key key, Value value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> seacher(root, key, value);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//在二分搜索树中找到相应元素并返回该元素的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Value <span style="color:#f92672">*</span><span style="color:#a6e22e">seacher</span>(Node <span style="color:#f92672">*</span>node, Key key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//找到key 返回value的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>(node<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> seacher(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> seacher(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="包含contain">包含(Contain)</h4>
<h5 id="逻辑-1">逻辑</h5>
<p>前面我们将了&quot;查找&quot;，其实&quot;包含&quot;的逻辑和&quot;查找&quot;是一样的，只是目的不同，&ldquo;查找&quot;的目的是找到我们需要找的节点并返回对应的地址；
<em><strong>&ldquo;包含(Contain)&ldquo;的目的是判断二分搜索树中是否存在一个节点，如果存在则返回true，否则返回false。</strong></em>
其逻辑和操作过程和&quot;查找(Search)&ldquo;一样的</p>
<h5 id="代码实现使用递归c实现-1">代码实现(使用递归，c++实现)</h5>
<p>在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//在树中寻找是否存在key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contain</span>(Key key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> contain(root, key);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//在二分搜索树中查找key，存在返回trun不存在返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contain</span>(Node <span style="color:#f92672">*</span>node, Key key) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//元素不存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//元素存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> contain(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> contain(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二分搜索树的遍历">二分搜索树的遍历</h3>
<h4 id="遍历的分类">遍历的分类</h4>
<p>二分搜索树遍历分为两大类，深度优先遍历和层序遍历。
深度优先遍历分为三种：先序遍历（preorder tree walk）、中序遍历（inorder tree walk）、后序遍历（postorder tree walk），分别为：
1、前序遍历：先访问当前节点，再依次递归访问左右子树。
2、中序遍历：先递归访问左子树，再访问自身，再递归访问右子树。
3、后序遍历：先递归访问左右子树，再访问自身节点。</p>
<h4 id="深度优先遍历">深度优先遍历</h4>
<ul>
<li>前序遍历：先访问当前节点，再依次递归访问左右子树。</li>
<li>中序遍历：先递归访问左子树，再访问自身，再递归访问右子树。</li>
<li>后序遍历：先递归访问左右子树，再访问自身节点。
为了更好理解深度优先遍历我们使用下图模型：</li>
</ul>
<p><img src="https://cdn.learnku.com/uploads/images/202105/19/69310/EUPIoIzVUv.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<h5 id="前序遍历">前序遍历：</h5>
<p>我们对二分搜索树中所有节点都分别标记3个点：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/tFiexYWwMP.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】">
<em><strong>开始遍历：</strong></em>
前序遍历是对每一个节点第一次访问的时候进行遍历：
<strong>28</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/SxihQcycfT.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】">
遍历：<strong>28， 16</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/kkl3yk87Lg.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/t48ECEKo7Y.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/IAXhvsJgpC.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/gd9UGhJaHL.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13， 22</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/re3b4j3Wev.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13， 22</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/RYEdRcmoSF.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13， 22</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/P6rcE8E8j3.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>遍历：<strong>28， 16， 13， 22</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/8taxRttJER.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>依次类推 ……</p>
<p>最后完成整个前序遍历：</p>
<p>遍历：<strong>28， 16， 13， 22， 30， 29， 42</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/I5DCkKqeHx.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】"></p>
<p>**代码实现(使用递归，c++实现)
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//前序遍历,传入节点，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> preOrder(root);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//前序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//不一定用打印，还可以对node-&gt;key和node-&gt;value进行操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  preOrder(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  preOrder(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="中序遍历">中序遍历</h5>
<p>按照前序遍历的模型和顺序，很容易看出中序遍历就是在中间点的时候进行遍历：（过程省略）
遍历：<strong>13， 16， 22， 28， 29， 30， 42</strong>
如下图：（可以看出由中序遍历可以看出遍历结果是有序的）</p>
<p><img src="https://cdn.learnku.com/uploads/images/202105/19/69310/4maBMMuf4u.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】">
**代码实现(使用递归，c++实现)
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//中序遍历，以节点为node的节点为根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inOrder(root);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//中序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        inOrder(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      inOrder(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="后序遍历">后序遍历</h5>
<p>一样的逻辑，后序遍历就是在第三个点时进行遍历：（过程省略）
遍历：<strong>13， 22， 16， 29， 42， 30， 28</strong>
如下图：
<img src="https://cdn.learnku.com/uploads/images/202105/19/69310/RygjvGSf0B.png!large" alt="二分搜索树系列之【 深度优先-层序遍历 (ergodic) 】">
后序遍历有个重要的应用：二叉树的销毁（从子节点依次向上删除）</p>
<p>**代码实现(使用递归，c++实现)
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//后序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> postOrder(root);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//后序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        postOrder(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        postOrder(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面我们来使用后序遍历将二分搜索树销毁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//析构函数的实现,其本质是后序遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">distroy</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            distroy(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>            distroy(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="广度优先遍历">广度优先遍历</h4>
<h5 id="介绍">介绍</h5>
<p>二分搜索树的广度优先（层序遍历），即逐层进行遍历，即将每层的节点存在队列当中，然后进行出队（取出节点）和入队（存入下一层的节点）的操作，以此达到遍历的目的。
<strong>通过引入一个队列来支撑层序遍历：</strong></p>
<ul>
<li>
<p>如果根节点为空，无可遍历；</p>
</li>
<li>
<p>如果根节点不为空：</p>
<ul>
<li>
<p>先将根节点入队；</p>
</li>
<li>
<p>只要队列不为空：</p>
<ul>
<li>
<p>出队队首节点，并遍历；</p>
</li>
<li>
<p>如果队首节点有左孩子，将左孩子入队；</p>
</li>
<li>
<p>如果队首节点有右孩子，将右孩子入队；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="具体数据">具体数据</h5>
<p>以下图为例：
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/ySF0wGBfpa.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<ol>
<li>我们使用一个队列——front
将28放入队列中</li>
</ol>
<p><strong>出：空</strong>
<strong>入：28</strong>
<strong>队列：28</strong>
<strong>遍历情况：空</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/JNXew3g72P.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：28</strong>
<strong>入：16， 30</strong>
<strong>队列：16， 30</strong>
<strong>遍历情况：28</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/VPQQbBSdWo.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：16</strong>
<strong>入：13 ，22</strong>
<strong>队列：30， 13， 22</strong>
<strong>遍历情况：28， 16</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/CgS25HU8lU.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：30</strong>
<strong>入：29 ，42</strong>
<strong>队列： 13， 22， 29， 42</strong>
<strong>遍历情况：28， 16， 30</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/xqXqRSEH2L.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：13</strong>
<strong>入：空</strong>
<strong>队列： 22， 29， 42</strong>
<strong>遍历情况：28， 16， 30， 13</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/mVMQJoKlrQ.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：22</strong>
<strong>入：空</strong>
<strong>队列：  29， 42</strong>
<strong>遍历情况：28， 16， 30， 13， 22</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/b95bmIzhVU.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：29</strong>
<strong>入：空</strong>
<strong>队列：  42</strong>
<strong>遍历情况：28， 16， 30， 13， 22， 29</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/xEBErizheX.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p><strong>出：42</strong>
<strong>入：空</strong>
<strong>队列：  空</strong>
<strong>遍历情况：28， 16， 30， 13， 22， 29， 42</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/pxWszTUvAk.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<p>遍历完成：
<strong>遍历情况：28， 16， 30， 13， 22， 29， 42</strong>
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/UleaXFO3nX.png!large" alt="二分搜索树系列之[ 深度优先-层序遍历 (ergodic) ]"></p>
<h5 id="代码实现使用递归c实现-2">代码实现(使用递归，c++实现)</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//层序遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">levelOrder</span>(){
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> q;   <span style="color:#75715e">//队列d
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    q.push(root);       <span style="color:#75715e">//将root入队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//队列不为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()){
</span></span><span style="display:flex;"><span>        Node <span style="color:#f92672">*</span>node  <span style="color:#f92672">=</span> q.front();    <span style="color:#75715e">//将队列第一个元素取出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        q.pop();             <span style="color:#75715e">//是删除栈顶元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span>node<span style="color:#f92672">-&gt;</span>key<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left)
</span></span><span style="display:flex;"><span>            q.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right)
</span></span><span style="display:flex;"><span>            q.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二分搜索树节点的删除remove">二分搜索树节点的删除(remove)</h3>
<p>在这一小节中，我们会介绍二分搜索树中如何查找最小最大值、最小最大值的删除、删除任意节点（删除只有左孩子的节点、删除只有右孩子的节点和删除左右孩子都存在的节点）；下面我们一一讲解：</p>
<h4 id="查找最小最大值及其删除">查找最小最大值及其删除</h4>
<h5 id="查找最小最大值">查找最小最大值</h5>
<p>其实很简单，首先我们想一想二分搜索树的定义就会明白，最小值在以跟节点的左孩子节点的左孩子节点………上，看图吧：</p>
<p><img src="https://cdn.learnku.com/uploads/images/202105/20/69310/KP58pjGbS0.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】"></p>
<p>直接看代码吧！
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 寻找二分搜索树的最小的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">minmum</span>(){
</span></span><span style="display:flex;"><span>    assert(count <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  Node<span style="color:#f92672">*</span> minnode <span style="color:#f92672">=</span> minmum(root);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> minnode<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 寻找二分搜索树的最小的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">minmum</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>           minmum(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> node;
</span></span></code></pre></div><p>对于最大值嘛，逻辑一样的这里就省略了
直接上代码吧！
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 寻找二分搜索树的最大的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">maxmum</span>(){
</span></span><span style="display:flex;"><span>    assert(count <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  Node<span style="color:#f92672">*</span> maxnode <span style="color:#f92672">=</span> maxmum(root);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> maxnode <span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 寻找二分搜索树的最大的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">maxmum</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>        maxmum(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="删除最小值最大值">删除最小值最大值</h5>
<p>以最大值为例：
其实就是将最大值找到，然后删除(
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/YaT2naV1U8.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】"></p>
<p>我们在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">//删除最大值的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeMax</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(root){
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> removeMax(root);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//从二分搜索树中删除最大值所在的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">removeMax</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">*</span> NODE <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>       count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> NODE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> removeMax(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同理，删除最小值也就是将最小值查找到，然后删除：
我们依然在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeMin</span>(){
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span>(root){
</span></span><span style="display:flex;"><span>	       root <span style="color:#f92672">=</span> removeMin(root);
</span></span><span style="display:flex;"><span>	   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">removeMin</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>		      Node<span style="color:#f92672">*</span> NODE <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>			  <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>			  <span style="color:#66d9ef">return</span> NODE;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	    node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span>  removeMin(node<span style="color:#f92672">-&gt;</span>left)<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> node; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="删除二分搜索树中任意节点">删除二分搜索树中任意节点</h4>
<h5 id="情况一">情况一</h5>
<p>删除只有左孩子(右孩子)的节点</p>
<p>例如下图，我们删除节点58，但此时它存在左孩子，而从二分搜索树的定义可知如果将58删除，就应该将50节点作为41节点的右孩子节点；所以我们需要在删除58节点之前将50节点变成41节点的右孩子。</p>
<p><img src="https://cdn.learnku.com/uploads/images/202105/20/69310/0grmxXnBUH.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】">
最后41节点的右子树应该变成：</p>
<pre tabindex="0"><code>        41
          \
           50  
          /   \
        42     53   
</code></pre><p>同理对于只有右孩子的节点是相同的逻辑（在这里省略)
下面看代码：(c++实现）
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//删除二分搜索树中值的任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>( Key key){
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> remove(root, key);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//删除二分搜索树中值的任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">remove</span>(Node<span style="color:#f92672">*</span> node, Key key){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//判断node是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//先找到需要删除的值的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>key) {      <span style="color:#75715e">//key为需要删除的，node-&gt;key为当前位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span>  remove(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> remove(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//这里就找到了需要delete的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span> {   <span style="color:#75715e">//key == node-&gt;key)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 待删除节点左子树为空的情况  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>               Node<span style="color:#f92672">*</span> rightNode <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>              count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">return</span> rightNode;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 待删除节点右子树为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>              Node<span style="color:#f92672">*</span> leftNode <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>              count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">return</span> leftNode;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h5 id="情况二">情况二</h5>
<p>删除同时拥有左右孩子的节点</p>
<p>如图，我们现在要删除图中58节点，如果直接删除58则41节点的右子树就不再是在该二分搜索树中了
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/86F5G0mToo.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】"></p>
<p>所以，现在我们需要将59拿出来，作为41节点的右孩子(这里只有59，53位置满足条件)
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/3puy9lQo9o.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】">
继续往下看：</p>
<p><img src="https://cdn.learnku.com/uploads/images/202105/20/69310/eUJ65gwM90.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】">
这里需要将原来58节点的右孩子变成59节点的右孩子
<code>s-&gt;right = delMin(d-&gt;right)</code></p>
<p><img src="https://cdn.learnku.com/uploads/images/202105/20/69310/l2iehzamJY.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】"></p>
<p>s-&gt;right = delMin(d-&gt;right)就变成了下图：
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/ukE8WF707i.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】"></p>
<p>再将50节点变成59的左孩子
<code> s-&gt;left = d-&gt;left</code>:
<img src="https://cdn.learnku.com/uploads/images/202105/20/69310/fB2hcp5fte.png!large" alt="二分搜索树系列之【 节点删除 (remove) 】"></p>
<p>最后将58节点删除即可；利用递归将59节点返回给41节点(成为41节点的右孩子)。</p>
<p>下面看代码：
在public中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//删除二分搜索树中值的任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>( Key key){
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> remove(root, key);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在private中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//删除二分搜索树中值的任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">remove</span>(Node<span style="color:#f92672">*</span> node, Key key){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//判断node是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//先找到需要删除的值的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>key) {      <span style="color:#75715e">//key为需要删除的，node-&gt;key为当前位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span>  remove(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> remove(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//这里就找到了需要delete的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span> {   <span style="color:#75715e">//key == node-&gt;key)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 待删除节点左子树为空的情况  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>               Node<span style="color:#f92672">*</span> rightNode <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>              count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">return</span> rightNode;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 待删除节点右子树为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>              Node<span style="color:#f92672">*</span> leftNode <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>              count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">return</span> leftNode;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>		      <span style="color:#75715e">// 待删除节点左右子树都不为为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         Node <span style="color:#f92672">*</span>succeer <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Node(minmum(node<span style="color:#f92672">-&gt;</span>right)); <span style="color:#75715e">//找到最小key值的节点返回给succeer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         count <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>         succeer<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> removeMin(node<span style="color:#f92672">-&gt;</span>right); <span style="color:#75715e">//将最小key值的node删除，并将返回值给succeer的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>         succeer<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>         count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> succeer;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二分搜索树完整源代码">二分搜索树完整源代码</h3>
<p>前面我们将了二分搜索树元素的插入、查找、遍历删除等，我将完整的源码放在这里了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cassert&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//套用模板函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Key, <span style="color:#66d9ef">typename</span> Value<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BST</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//构造节点Node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>        Key key;
</span></span><span style="display:flex;"><span>  Value value;
</span></span><span style="display:flex;"><span>  Node <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>  Node <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Node(Key key, Value value) {
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//初始值为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>             <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>        Node(Node <span style="color:#f92672">*</span>node){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>key;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>value;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node <span style="color:#f92672">*</span>root;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> count;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    BST() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//初始值为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  root <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>BST() {
</span></span><span style="display:flex;"><span>        distroy(root);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isEmpty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//插入操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(Key key, Value value) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//向根节点中插入key， value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         root <span style="color:#f92672">=</span> insert(root, key, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//在树中寻找是否存在key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contain</span>(Key key) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> contain(root, key);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//找到key相应的节点并且返回value的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node <span style="color:#f92672">*</span><span style="color:#a6e22e">seacher</span>(Key key, Value value) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> seacher(root, key, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//前序遍历,传入节点，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> preOrder(root);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//中序遍历，以节点为node的节点为根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> inOrder(root);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//后序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> postOrder(root);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//层序遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">levelOrder</span>(){
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(root);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//队列不为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()){
</span></span><span style="display:flex;"><span>            Node <span style="color:#f92672">*</span>node  <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cout<span style="color:#f92672">&lt;&lt;</span>node<span style="color:#f92672">-&gt;</span>key<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left)
</span></span><span style="display:flex;"><span>                q.push(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right)
</span></span><span style="display:flex;"><span>                q.push(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 寻找二分搜索树的最小的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">minmum</span>(){
</span></span><span style="display:flex;"><span>        assert(count <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">*</span> minnode <span style="color:#f92672">=</span> minmum(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> minnode<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 寻找二分搜索树的最大的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">maxmum</span>(){
</span></span><span style="display:flex;"><span>        assert(count <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        Node<span style="color:#f92672">*</span> maxnode <span style="color:#f92672">=</span> maxmum(root);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> maxnode <span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//删除最小值的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeMin</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root)
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> removeMin(root);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//删除最大值的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removeMax</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root)
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> removeMax(root);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//删除二分搜索树中值的任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>( Key key){
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> remove(root, key);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//插入操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">//向以node为根节点的二分搜索树中，插入节点（key，value),使用递归算法 //返回插入新节点后的二分搜索树的根 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> Node <span style="color:#f92672">*</span>insert(Node <span style="color:#f92672">*</span>node, Key key, Value value) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Node</span>(key, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>         } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">-&gt;</span>right, key, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">//key &lt; node-&gt;key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">-&gt;</span>left, key, value);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//在二分搜索树中查找key，存在返回trun不存在返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">contain</span>(Node <span style="color:#f92672">*</span>node, Key key) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//元素不存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//元素存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> contain(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> contain(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//在二分搜索树中找到相应元素并返回该元素的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Value <span style="color:#f92672">*</span><span style="color:#a6e22e">seacher</span>(Node <span style="color:#f92672">*</span>node, Key key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//找到key 返回value的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>(node<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> seacher(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> seacher(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//前序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//不一定用打印，还可以对node-&gt;key和node-&gt;value进行操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>               cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>               preOrder(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>               preOrder(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//中序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            inOrder(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            inOrder(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//后序遍历，以node为根节点的二分搜索树进行前序遍历，打印节点相应信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            postOrder(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            postOrder(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> node<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//析构函数的实现,其本质是后序遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">distroy</span>(Node <span style="color:#f92672">*</span>node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            distroy(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>            distroy(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 寻找二分搜索树的最小的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">minmum</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>                minmum(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>             }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 寻找二分搜索树的最大的键值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">maxmum</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">!=</span> NULL){
</span></span><span style="display:flex;"><span>            maxmum(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从二分搜索树中删除最小值所在的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">removeMin</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>            Node<span style="color:#f92672">*</span> NODE <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NODE;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>         node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> removeMax(node<span style="color:#f92672">-&gt;</span>left);
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//从二分搜索树中删除最大值所在的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">removeMax</span>(Node<span style="color:#f92672">*</span> node){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>            Node<span style="color:#f92672">*</span> NODE <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>            count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NODE;
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> removeMax(node<span style="color:#f92672">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//删除二分搜索树中值的任意节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">remove</span>(Node<span style="color:#f92672">*</span> node, Key key){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//判断node是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">if</span>(node <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       <span style="color:#75715e">//先找到需要删除的值的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span>  remove(node<span style="color:#f92672">-&gt;</span>left, key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">-&gt;</span>key) {
</span></span><span style="display:flex;"><span>            node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> remove(node<span style="color:#f92672">-&gt;</span>right, key);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//这里就找到了需要delete的node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> {   <span style="color:#75715e">//key == node-&gt;key)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>               <span style="color:#75715e">// 待删除节点左子树为空的情况 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>                    Node<span style="color:#f92672">*</span> rightNode <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>                    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> rightNode;
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 待删除节点右子树为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>                    Node<span style="color:#f92672">*</span> leftNode <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>                    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> leftNode;
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 待删除节点左右子树都不为为空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 Node <span style="color:#f92672">*</span>succeer <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Node(minmum(node<span style="color:#f92672">-&gt;</span>right)); <span style="color:#75715e">//找到最小key值的节点返回给succeer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 count <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                 succeer<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> removeMin(node<span style="color:#f92672">-&gt;</span>right); <span style="color:#75715e">//将最小key值的node删除，并将返回值给succeer的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>                 succeer<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>left;
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">delete</span> node;
</span></span><span style="display:flex;"><span>                 count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">return</span> succeer;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shuffle</span>( <span style="color:#66d9ef">int</span> arr[], <span style="color:#66d9ef">int</span> n ){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    srand( time(NULL) );
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">--</span> ){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> rand()<span style="color:#f92672">%</span>(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  swap( arr[i] , arr[x] );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>测试也写在这里了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 测试 remove
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    srand(time(NULL));
</span></span><span style="display:flex;"><span>    BST<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> bst <span style="color:#f92672">=</span> BST<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 取n个取值范围在[0...n)的随机整数放进二分搜索树中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> n ; i <span style="color:#f92672">++</span> ){
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> rand()<span style="color:#f92672">%</span>n;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 为了后续测试方便,这里value值取和key值一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> key;
</span></span><span style="display:flex;"><span>    bst.insert(key,value);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 注意, 由于随机生成的数据有重复, 所以bst中的数据数量大概率是小于n的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// order数组中存放[0...n)的所有元素  int order[n];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> n ; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>          order[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 打乱order数组的顺序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   shuffle( order , n );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 乱序删除[0...n)范围里的所有元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ; i <span style="color:#f92672">&lt;</span> n ; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>( bst.contain( order[i] )){
</span></span><span style="display:flex;"><span>            bst.remove( order[i] );
</span></span><span style="display:flex;"><span>   cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;After remove &#34;</span><span style="color:#f92672">&lt;&lt;</span>order[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; size = &#34;</span><span style="color:#f92672">&lt;&lt;</span>bst.size()<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最终整个二分搜索树应该为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> bst.size() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（图片来源：慕课网bobo老师）</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
